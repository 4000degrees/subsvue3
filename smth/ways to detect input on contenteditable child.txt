methods
findSelectedTitle(event) {
  // get currently focused html in the editor to figure out which subtitle we are working on
  var selectedElement = null;
  if (!window.getSelection().focusNode) {
    return null;
  }
  selectedElement = window.getSelection().focusNode;
  if (!this.$el.contains(selectedElement) || this.$el === selectedElement) {
    return null;
  }
  if (!selectedElement.classList) {
    selectedElement = selectedElement.parentNode;
  }
  while (!selectedElement.classList.contains("title")) {
    selectedElement = selectedElement.parentNode;
  }
  this.currentSubtitle = selectedElement
  return selectedElement
},

computed
currentSubtitle(currentSubtitle, previousSubtitle) {
  if (previousSubtitle.classList) {
    previousSubtitle.classList.remove('focus');
  }
  currentSubtitle.classList.add('focus');
}

mounted
// this.$store.commit("updateSubtitleText", {
//   // first way to detect input on child
//   // since the subtitle itself doesn't have
//   // input events and thus can't put new text into model, the editor has to handle this
//   id: this.$store.state.currentSubtitle.id,
//   text: this.$store.state.currentSubtitle.innerHTML
// })


// 2nd way to detect input on child of contenteditable
// this.$parent.$el.addEventListener("input", function(event) {
//   var selectedElement = window.getSelection().focusNode;
//   if (this.$el.contains(selectedElement)) {
//     while (selectedElement !== this.$el) {
//       selectedElement = selectedElement.parentNode;
//     }
//     console.log(selectedElement)
//     this.$store.commit("updateSubtitle", {
//       obj: this.subtitle,
//       text: selectedElement.innerHTML
//     })
//   }
// }.bind(this))


methods: {
  // third way to detect input
  // v-observer:subtree.characterData="onCharacterDataChange"
  onCharacterDataChange(mutationsList) {
    this.$store.commit("updateSubtitle", {
      obj: this.subtitle,
      text: this.$el.innerHTML
    })
  },
}
